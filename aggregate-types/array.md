# array

Go 中数组是一个长度固定，元素类型相同的集合组成的数据结构；

可以看出数组具有2个特征：
- 数组长度固定
- 元素类型相同

那么当 2 个数组进行相等比较时，必须同时满足以上特征，才是相等的，否则就是不相等的([2]int 和 [3]int 是不相等的2个数组)
> 数组之间可以使用 `==` 或 `!=` 进行相等比较，但不可以使用 `<` 或 `>` 进行大小比较

数组是值类型:
- 当数组 A 赋值给另一个数组 B 时，会 copy A 中所有元素
- 当数组 A 作为函数的参数时，函数接受到的是 A 的 copy 对象，而非指针引用对象 

数组占用的内存是连续分配的:
- 由于内存连续，cpu 能把正在使用的数据缓存的更久
- 内存连续很容易计算索引，可以快速迭代数组里的所有元素
> 数组是构造切片和 map 的基石

## 初始化

Go 中有 2 种不同的方式创建数组
- 显式指定数组长度大小：`arr := [2]int{1, 2}`
- 隐式编译器推导数组长度大小：`arr := [...]int{1, 2}`

以上 2 种方式在运行时得到的数组是一样的，只不过后一种方式在编译期间会转化成前者

## 访问 和 赋值

```go
package main

import (
	"fmt"
)

func main() {
	arr := [...]int{1, 2, 3}
	// 访问
	fmt.Println(arr[1]) // output: 2
	// 赋值
	arr[1] = 0
	fmt.Println(arr) // output: [1 0 3]
}
```

## 数组的指针 和 指针数组的区别

- 数组的指针：即一个指向数组的指针，如： var p *[2]int
- 指针数组：数组中元素是指针，如：var p [2]*int

数组的指针:

```go
package main

import (
	"fmt"
)

func main() {
	// 使用 new 初始化指针数组
	arr := new([2]int)
	fmt.Println(*arr)
	// set index 1
	arr[1] = 2
	fmt.Println(*arr)

	// 使用字面量初始化指针数组
	var arr2 *[2]int = &[...]int{3, 4}
	arr2 = &[...]int{3, 4}
	fmt.Println(*arr2)

	// output:
	/*
		[0 0]
		[0 2]
		[3 4]
	*/
}
```

指针数组:

```go
// 指针数组，数组中元素是指针类型的
x, y := 1, 2
a := [...]*int{&x, &y}
fmt.Println(a) // 输出 [0xc420016090 0xc420016098] 输出的是 
```
