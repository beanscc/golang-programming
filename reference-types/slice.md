# slice

slice 是一种数据结构，是围绕动态数组的概念构建的，可以按需自动增长或缩小；
slice 动态增长：是通过内置函数 append 来实现的，这个函数可以快速且高效地增长切片；
slice 缩小：通过对切片再次切片来缩小一个切片的大小

切片底层内存中也是连续块中分配的

### 内部实现

切片有三个字段的数据结构，分别是：指向底层数组的指针、切片访问的元素的个数（即长度）、切片允许增长到的元素个数（即容量）

> 切片长度和容量的区别：

> 不允许创建容量小于长度的切片

### 创建切片的 2 中方式

- 使用 make 关键字
- 使用切片字面量

#### 使用 make 函数

使用长度声明一个字符串切片：

```go
// 创建一个字符串切片
// 其长度和容量都是 5 个元素 
slice := make([]string, 5)
```

如果只指定长度，那么切片的容量和长度相等



使用长度和容量声明整型切片

```go
// 创建一个整型切片
// 其长度为 3 个元素，容量为 5 个元素 
slice := make([]int, 3, 5)
```

分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但是初始化后并不能 访问所有的数组元素

#### 通过切片字面量来声明切片

```go
// 创建字符串切片
// 其长度和容量都是 5 个元素
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}

// 创建一个整型切片
// 其长度和容量都是 3 个元素 
sliceInt := []int{10, 20, 30}
```


当使用切片字面量时，可以设置初始长度和容量。要做的就是在初始化时给出所需的长 度和容量作为索引；如下：

使用索引声明切片

```go
// 创建字符串切片
// 使用空字符串初始化第 100 个元素 
slice := []string{99: ""}
```

### nil 和空切片

#### nil 切片

#### 空切片

声明空切片

```go
// 使用 make 创建空的整型切片
slice := make([]int, 0)

// 使用切片字面量创建空的整型切片 
slice := []int{}
```

空切片在底层数组包含 0 个元素，也没有分配任何存储空间

### 在函数间传递切片

在函数间传递切片，就是要以值的方式传递切片。由于切片的尺寸很小，在函数间复制和传递切片成本也很低。

在 64 位架构的机器上，一个切片需要 24 字节的内存:指针字段需要 8 字节，长度和容量字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片 复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。

在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指
针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本

## 相关文章

- https://blog.golang.org/slices
- https://blog.golang.org/go-slices-usage-and-internals