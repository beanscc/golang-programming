# array

Go 中数组是一个长度固定，元素类型相同的集合组成的数据结构；

具有2个特征：
- 数组长度固定
- 元素类型相同

数组一旦声明，其长度和元素类型就不允许改变了；

若需要存储更多的元素，则需要先创建一个更长的数组，再把原数组中的元素赋值到新数组中

那么当 2 个数组进行相等比较时，必须同时满足以上特征，才是相等的，否则就是不相等的（`[2]int` 和 `[3]int` 是不相等的2个数组）
> 数组之间可以使用 `==` 或 `!=` 进行相等比较，但不可以使用 `<` 或 `>` 进行大小比较



数组是值类型:
- 当数组 A 赋值给另一个数组 B 时，会 copy A 中所有元素
- 当数组 A 作为函数的参数时，函数接受到的是 A 的 copy 对象，而非指针引用对象 



数组占用的内存是连续分配的:
- 由于内存连续，cpu 能把正在使用的数据缓存的更久
- 内存连续很容易计算索引，可以快速迭代数组里的所有元素
> 数组是构造切片和 map 的基石



## 初始化

Go 中不同的方式创建数组：
- 变量声明方式：`var arr [2]int`，得到数组为 `[2]int{0, 0}`
- 字面量声明
    - 显式指定数组长度大小和元素值：`arr := [2]int{1, 2}`
    - 显式指定元素值(隐式编译器推导数组长度大小)：`arr := [...]int{1, 2}`，编译器根据指定的元素个数自动推导数组长度大小
    - 显式指定特定索引位置的元素：`arr := [5]{1:1, 3:3}`，得到的数组为 `[5]{0, 1, 0, 3, 0}`

通过 `...` 方式不明确指定数组大小的声明方式，会在编译期间由编译器推导转化显示声明的形式

## 访问 和 赋值

```go
package main

import (
	"fmt"
)

func main() {
	arr := [...]int{1, 2, 3}
	// 访问
	fmt.Println(arr[1]) // output: 2
	// 赋值
	arr[1] = 0
	fmt.Println(arr) // output: [1 0 3]
}
```

## 数组的指针 和 指针数组的区别

- 数组的指针：即一个指向数组的指针，如：`var p *[2]int`
- 指针数组：数组中元素是指针，如：`var p [2]*int`

数组的指针:

```go
package main

import (
	"fmt"
)

func main() {
	// 使用 new 初始化指针数组
	arr := new([2]int)
	fmt.Println(*arr)
	// set index 1
	arr[1] = 2
	fmt.Println(*arr)

	// 使用字面量初始化指针数组
	var arr2 *[2]int = &[...]int{3, 4}
	arr2 = &[...]int{3, 4}
	fmt.Println(*arr2)

	// output:
	/*
		[0 0]
		[0 2]
		[3 4]
	*/
}
```

指针数组:

```go
// 指针数组，数组中元素是指针类型的
x, y := 1, 2
a := [...]*int{&x, &y}
fmt.Println(a) // 输出 [0xc420016090 0xc420016098] 输出的是 
```
